TRUNCATE TABLE EDW_WORK.ECDM_REL_PARTY_ADDRESS;


INSERT INTO EDW_WORK.ECDM_REL_PARTY_ADDRESS
(
    DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    PRIMARY_ADDRESS_IND,
    BEGIN_DT,
    BEGIN_DTM,
    ROW_PROCESS_DTM,
    AUDIT_ID,
    LOGICAL_DELETE_IND,
    CHECK_SUM,
    CURRENT_ROW_IND,
    END_DT,
    END_DTM,
    SOURCE_SYSTEM_ID,
    RESTRICTED_ROW_IND,
    UPDATE_AUDIT_ID
)
SELECT
    UUID_GEN(PREHASH_VALUE(
        CLEAN_STRING(ADDR.AD_L1_TXT),
        CLEAN_STRING(ADDR.AD_L2_TXT),
        CLEAN_STRING(ADDR.AD_L3_TXT),
        CLEAN_STRING(ADDR.AD_L4_TXT),
        CLEAN_STRING(ADDR.CITY),
        CLEAN_STRING(ADDR.STATE),
        CLEAN_STRING(ADDR.ZIP_1_5_NR),
        CLEAN_STRING(ADDR.ZIP_6_9_NR),
        CLEAN_STRING(ADDR.ZIP_10_13_NR),
        CLEAN_STRING(ADDR.CTRY_CD)))::UUID AS DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    UUID_GEN(PREHASH_VALUE(CLEAN_STRING(SRC.AD_TYP_CD)))::UUID AS REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    UUID_GEN(PREHASH_VALUE('ECDM'))::UUID AS REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    UUID_GEN(PREHASH_VALUE(SRC.SRC_SYS_PRTY_ID))::UUID AS DIM_PARTY_NATURAL_KEY_HASH_UUID,
    NULL AS PRIMARY_ADDRESS_IND,
    SRC.PRTY_AD_FR_DT AS BEGIN_DT,
    SRC.PRTY_AD_FR_DT AS BEGIN_DTM,
    CURRENT_TIMESTAMP(6) AS ROW_PROCESS_DTM,
    0 AS AUDIT_ID,
    CASE WHEN SRC.SRC_DEL_IND = 'Y' THEN TRUE ELSE FALSE END AS LOGICAL_DELETE_IND,
    UUID_GEN(NULL)::UUID AS CHECK_SUM,
    CASE WHEN SRC.CURR_IND = 'Y' THEN TRUE ELSE FALSE END AS CURRENT_ROW_IND,
    SRC.PRTY_AD_TO_DT AS END_DT,
    SRC.PRTY_AD_TO_DT AS END_DTM,
    SRC.SRC_SYS_ID AS SOURCE_SYSTEM_ID,
    FALSE AS RESTRICTED_ROW_IND,
    0 AS UPDATE_AUDIT_ID

FROM PROD_STND_PRTY_VW_TERSUN.PRTY_AD_VW SRC
LEFT JOIN PROD_STND_PRTY_VW_TERSUN.ST_AD_VW ADDR
ON SRC.SRC_SYS_AD_ID = ADDR.SRC_SYS_AD_ID;


--TRANSFORM SOURCE DATA TO ALIGN TO TARGET
CREATE LOCAL TEMPORARY TABLE ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP1 ON COMMIT PRESERVE ROWS AS
SELECT DISTINCT
UUID_GEN(PREHASH_VALUE(CLEAN_STRING(SRC_SYS_PRTY_ID))) AS DIM_PARTY_NATURAL_KEY_HASH_UUID,
    SRC_SYS_AD_ID AS ADDRESS_KEY,
    UUID_GEN(PREHASH_VALUE(CLEAN_STRING(AD_TYP_CD))) AS REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    UUID_GEN(PREHASH_VALUE(CLEAN_STRING(CARR_ADMIN_SYS_CD))) AS REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    PRTY_AGMT_AD_FR_DT::DATE AS BEGIN_DT,
    PRTY_AGMT_AD_FR_DT::DATE::TIMESTAMP AS BEGIN_DTM,
    PRTY_AGMT_AD_TO_DT::DATE AS END_DT,
    PRTY_AGMT_AD_TO_DT::DATE::TIMESTAMP AS END_DTM
FROM PROD_STND_PRTY_VW_TERSUN.PRTY_AGMT_AD_VW
ORDER BY REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    END_DT,
    BEGIN_DT,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY;
-- 1. The inner subquery groups together records with the same key and end_dt. We filter only on the record with the earliest begin_dt when there is a shared end_dt.
-- 2. We then create a sequencer for each natural key combination and order by begin_dt. This will be used in calculations in the next step


CREATE LOCAL TEMPORARY TABLE ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP2 ON COMMIT PRESERVE ROWS AS
SELECT DIM_PARTY_NATURAL_KEY_HASH_UUID,
       ADDRESS_KEY,
       REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
       REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
       BEGIN_DT,
       BEGIN_DTM,
       END_DT,
       END_DTM
, ROW_NUMBER() OVER(PARTITION BY
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID ORDER BY BEGIN_DT) AS SEQ
FROM (
		SELECT *
		, ROW_NUMBER() OVER(PARTITION BY DIM_PARTY_NATURAL_KEY_HASH_UUID,
            REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
            ADDRESS_KEY,
            REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
            END_DT ORDER BY BEGIN_DT) AS RANKING
		FROM ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP1) T1
WHERE RANKING = 1
ORDER BY RANKING,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    END_DT,
    BEGIN_DT,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY;
--Here we capture the min begin date and max end date for records with a lower sequence number than current.
--these will be used in step 4


CREATE LOCAL TEMPORARY TABLE ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP3 ON COMMIT PRESERVE ROWS AS
SELECT DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    BEGIN_DT,
    END_DT,
    SEQ,
    MIN(Tminus1BEGIN_DT) AS Tminus1BEGIN_DT,
    MAX(Tminus1END_DT) AS Tminus1END_DT
FROM (SELECT CUR.DIM_PARTY_NATURAL_KEY_HASH_UUID,
		CUR.ADDRESS_KEY,
		CUR.REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
		CUR.REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
		Prev.END_DT AS Tminus1END_DT,
		Prev.BEGIN_DT AS Tminus1BEGIN_DT,
		CUR.BEGIN_DT,
		CUR.END_DT,
		CUR.SEQ
	FROM ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP2 CUR
	LEFT OUTER JOIN ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP2 Prev
		ON CUR.DIM_PARTY_NATURAL_KEY_HASH_UUID = Prev.DIM_PARTY_NATURAL_KEY_HASH_UUID
		AND CUR.ADDRESS_KEY = Prev.ADDRESS_KEY
		AND CUR.REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID = Prev.REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID
		AND CUR.REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID = Prev.REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID
		AND Prev.SEQ < CUR.SEQ
	) BASE
GROUP BY DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    BEGIN_DT,
    END_DT,
    SEQ
ORDER BY SEQ,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    END_DT,
    BEGIN_DT,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY;
--we apply some rules here to align begin and end dates
--Rule 1: if two records partially overlap, we set the begin_dt of a record to the prior record's end_dt + 1
--Rule 2: if a record is completely overlapped, we set keep_ind = 0 because we won't want to include this in our final table


CREATE LOCAL TEMPORARY TABLE ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP4 ON COMMIT PRESERVE ROWS AS
SELECT DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    CASE WHEN Tminus1END_DT >= BEGIN_DT THEN Tminus1END_DT + 1 ELSE BEGIN_DT END AS BEGIN_DT,
    END_DT,
    SEQ,
CASE WHEN END_DT <= Tminus1END_DT THEN 0 ELSE 1 END AS KEEP_IND
FROM ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP3
ORDER BY KEEP_IND,
    SEQ,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    END_DT,
    BEGIN_DT,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    ADDRESS_KEY;


INSERT INTO EDW_WORK.ECDM_REL_PARTY_ADDRESS
(
    DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    PRIMARY_ADDRESS_IND,
    BEGIN_DT,
    BEGIN_DTM,
    ROW_PROCESS_DTM,
    AUDIT_ID,
    LOGICAL_DELETE_IND,
    CHECK_SUM,
    CURRENT_ROW_IND,
    END_DT,
    END_DTM,
    SOURCE_SYSTEM_ID,
    RESTRICTED_ROW_IND,
    UPDATE_AUDIT_ID
)
SELECT
    DISTINCT
    UUID_GEN(PREHASH_VALUE(CLEAN_STRING(ADDR.AD_L1_TXT), CLEAN_STRING(ADDR.AD_L2_TXT), CLEAN_STRING(ADDR.AD_L3_TXT), CLEAN_STRING(ADDR.AD_L4_TXT), CLEAN_STRING(ADDR.CITY), CLEAN_STRING(ADDR.STATE), CLEAN_STRING(ADDR.ZIP_1_5_NR), CLEAN_STRING(ADDR.ZIP_6_9_NR), CLEAN_STRING(ADDR.ZIP_10_13_NR), CLEAN_STRING(ADDR.CTRY_CD)))::UUID AS DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    SRC.REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID::UUID AS REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    SRC.REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID::UUID AS REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    SRC.DIM_PARTY_NATURAL_KEY_HASH_UUID::UUID AS DIM_PARTY_NATURAL_KEY_HASH_UUID,
    NULL AS PRIMARY_ADDRESS_IND,
    SRC.BEGIN_DT AS BEGIN_DT,
    SRC.BEGIN_DT::DATE::TIMESTAMP AS BEGIN_DTM,
    CURRENT_TIMESTAMP(6) AS ROW_PROCESS_DTM,
    1 AS AUDIT_ID,
    FALSE AS LOGICAL_DELETE_IND,
    UUID_GEN(NULL)::UUID AS CHECK_SUM,
    CASE WHEN SRC.END_DT > '9000-01-01' THEN TRUE ELSE FALSE END AS CURRENT_ROW_IND,
    SRC.END_DT AS END_DT,
    SRC.END_DT::DATE::TIMESTAMP +  (INTERVAL '1 day') - (INTERVAL '1 second') AS END_DTM,
    '45' AS SOURCE_SYSTEM_ID,
    FALSE AS RESTRICTED_ROW_IND,
    0 AS UPDATE_AUDIT_ID

FROM ECDM_REL_PARTY_ADDRESS_METADATA_GAP_FIX_STEP4 SRC
LEFT JOIN EDW_STAGING.ECDM_ST_AD_VW ADDR
ON SRC.ADDRESS_KEY = ADDR.SRC_SYS_AD_ID
WHERE SRC.KEEP_IND = 1;


DELETE FROM EDW_TDSUNSET.REL_PARTY_ADDRESS WHERE SOURCE_SYSTEM_ID IN ('44', '45');


INSERT INTO EDW_TDSUNSET.REL_PARTY_ADDRESS
(
    DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    PRIMARY_ADDRESS_IND,
    BEGIN_DT,
    BEGIN_DTM,
    ROW_PROCESS_DTM,
    AUDIT_ID,
    LOGICAL_DELETE_IND,
    CHECK_SUM,
    CURRENT_ROW_IND,
    END_DT,
    END_DTM,
    SOURCE_SYSTEM_ID,
    RESTRICTED_ROW_IND,
    UPDATE_AUDIT_ID
)

SELECT
    DIM_ADDRESS_NATURAL_KEY_HASH_UUID,
    REF_ADDRESS_TYPE_NATURAL_KEY_HASH_UUID,
    REF_PARTY_CONTACT_SOURCE_NATURAL_KEY_HASH_UUID,
    DIM_PARTY_NATURAL_KEY_HASH_UUID,
    PRIMARY_ADDRESS_IND,
    BEGIN_DT,
    BEGIN_DTM,
    ROW_PROCESS_DTM,
    AUDIT_ID,
    LOGICAL_DELETE_IND,
    CHECK_SUM,
    CURRENT_ROW_IND,
    END_DT,
    END_DTM,
    SOURCE_SYSTEM_ID,
    RESTRICTED_ROW_IND,
    UPDATE_AUDIT_ID

FROM EDW_WORK.ECDM_REL_PARTY_ADDRESS;
